# Day 02 - Go Boot camp

[Link to EN README.md version](README.md)

## Содержание

1. [Глава I](#chapter-i) \
    1.1. [Основные правила](#general-rules)
2. [Глава II](#chapter-ii) \
    2.1. [Правила дня](#rules-of-the-day)
3. [Глава III](#chapter-iii) \
    3.1. [Введение](#intro)
4. [Глава IV](#chapter-iv) \
    4.1. [Упражнение 00: Поиск штуковин](#exercise-00-finding-things)
5. [Глава V](#chapter-v) \
    5.1. [Упражнение 01: Подсчет штуковин](#exercise-01-counting-things)
6. [Глава VI](#chapter-vi) \
    6.1. [Упражнение 02: Запуск штуковин](#exercise-02-running-things)
7. [Глава VII](#chapter-vii) \
    7.1. [Упражнение 03: Архивирование штуковин](#exercise-03-archiving-things)


<h2 id="chapter-i">Глава I</h2>
<h2 id="general-rules">Основные правила</h2>

* Твоя программа не должна закрываться неожиданно (выдавая ошибку при корректном вводе). Если это произойдет, твой проект будет считаться неработаспособным и получит 0 во время оценки.
* Мы рекомендуем тебе писать тесты для твоего проекта, даже если если они и не оцениваются. Это даст тебе возможность легко тестировать твою работу и работу твоих пиров. Ты убедишься что тесты очень полезны, во время защиты. Во время защиты ты свободен использовать свои тесты и/или тесты пира которого ты проверяешь.
* Отправляй свою работу в нужный git репозиторий. Работа будет оцениваться только из git репозитория.
* Если твой код использует сторонние зависимости, следует использовать [Go Modules](https://go.dev/blog/using-go-modules) для управления ими.

<h2 id="chapter-ii">Глава II</h2>
<h2 id="rules-of-the-day">Правила дня</h2>

* Пиши код только в `*.go` файлах и (в случае стронних зависимостей) `go.mod` + `go.sum`
* Твой код для этого задания должен собираться с использовния простого `go build`

<h2 id="chapter-iii">Глава III</h2>
<h2 id="intro">Введение</h2>


Это завораживает как много ты можешь сделать используя иструменты командной строки. Практически любая ОС, включая встроенные имеет свой собственный CLI и набор маленьких программ для совершения магических штук. Как пример ты можешь почитать про [BusyBox](https://ru.wikipedia.org/wiki/BusyBox), который вообще швейцарский нож для различных систем, начиная от роутеров на базе линукс на OpenWRT и до телефонов на Android.

Мы не пытаемся переизобрести велосипед тут, но знак как работать с файловой систем и производить основные CLI штуки в Golang может быть по-настоящему полезно, так что давай потратим немного времени на это.

<h2 id="chapter-iv" >Глава IV</h2>
<h3 id="ex00">Упражнение 00: Поиск штуковин</h3>

В качестве первого шага давай реализуем а-ля `find` утилиту используя Go. Она будет принимать некоторый путь и набор опций(аргументов) командной строки и будет способна искать различны типы сущностей. Нас интересует три типа сущностей:
* Папки (директории)
* Обычные файлы
* Cим-ссылки (symbolic links)

И так мы должны сделать запуск нашей программы таким образом:

```bash
# Поиск всех файлов/папок/сим-ссылок рекурсивно в директории /foo
./myFind /foo
/foo/bar
/foo/bar/baz
/foo/bar/baz/deep/directory
/foo/bar/test.txt
/foo/bar/buzz -> /foo/bar/baz
/foo/bar/broken_sl -> [broken]
```

или задавать фалаги `-ls`, `-d` или `-f` для вывода только сим-ссылок, только директорий или только файлов. Держи в голове что пользователь может выбреть одну, две, или сразу три опции типа `./myFind -f -sl /path/to/dir` или `./myFind -d /path/to/other/dir`.

Ты так же должен имплементировать еще одну обработку аргумента `-ext` (работает ТОЛЬКО если `-f` задан) для пользователя возможность отображать только файлы с заданным расширением. Расширение в этом задннии это последняя часть имени файла если мы разделим его через точку, так,

```bash
# Поиск только *.go файлов игнорируя все остальные.
./myFind -f -ext 'go' /go
/go/src/github.com/mycoolproject/main.go
/go/src/github.com/mycoolproject/magic.go
```

Тебе так же нужно обрабатывать сим-ссылки. Так если `/foo/bar/buzz` это сим-ссылка указывающая куда-то в другое место файловой системы типа `/foo/bar/baz`, выведи оба пути разделенными через `->`, как в примере выше.

Другая вещь про сим-ссылке это то что они могут быть быть сломанными (указывать на на существующий файловый узел). В этом случае твой код дожен выводить `[broken]` вместо пути на который указывает ссылка.

Файлы и директории к которым текущий пользователь не имеет доступа (permission errors) должны быть пропущены в выводе и не приводить к ошибке выполнения (runtime error).

<h2 id="chapter-v" >Глава V</h2>
<h3 id="ex01">Упражнение 01: Подсчет штуковин</h3>

Сейчас мы можем искать наши файлы, но нам может понадобиться больше мета-информации о том что в этих файлах. Давай реализуем а-ля `wc` инструмент для сбора базовой статистики о наших файлах.

Сперва, давай предположим что наши файлы представляют собой текстовые файлы в utf-8 кодировке, таким образом твой код должен работать с файлами содержащими русские символы (забудь о краевых случаях по типу арабского языка пока что, сейчас требуется только Английские и Русские символы). Ты можешь игнорировать пункцию и просто использовать пробел в качестве разделителя слов.

Ты должен релизовать три взаимоисключащих (только один может быть задан при запуске, в другом случае сообщение об ошибке будет выведено) флага для своего кода `-l` для подсчета строк, `-m` для подсчета символов и `-w` для подсчета слов. Твоя программа должна запускаться так:

```bash
# Подсчет слов в файле input.txt
./myWc -w input.txt
777 input.txt
# Подсчет строк в файлах input2.txt и input3.txt
./myWc -l input2.txt input3.txt
42 input2.txt
53 input3.txt
# Подсчет символов в файлах input4.txt, input5.txt и input6.txt
./myWc -m input4.txt input5.txt input6.txt
1337 input4.txt
2664 input5.txt
3991 input6.txt
```

Как ты можешь видеть, ответ это всегда вычисленное число и название файла разделенные табом (`\t`). Если ни один флаг не был задан, используй поведение определенное для флага `-w`.

**Важно**: так все файлы независимы между собой, ты должен использовать горутины (goroutines) для обработки файлов конкуррентно. Ты можешь стартануть столько горутин сколько файлов было передано для твоей программы.

<h2 id="chapter-vi" >Глава VI</h2>
<h3 id="ex02">Упражнение 02: Запуск штуковин</h3>

Ты знаешь что такое `xargs`? Ты можешь почитать об этом [тута](https://shapeshed.com/unix-xargs/), например. Давай реализуем похожий инструмент - в этом упражнении тебе предстоит написать утилиты которая будет:


1) обрабатывать все параметры как комманды, типа `wc -l` или `ls -la`
2) запускать команду передавая ей аргумент за аргументов, котрые разделены новой строкой.

Пример
```bash
echo -e "/a\n/b\n/c" | ./myXargs ls -la
```

это эквивалентно команде ниже:

```bash
ls -la /a /b /c
```

Ты можешь потестить этот инструмент совместно с теми что ты были в предыдущем упражнении

```bash
./myFind -f -ext 'log' /path/to/some/logs | ./myXargs ./myWc -l
```

эта команда будет вычислять количество строк для `.log` файлов в папке `/path/to/some/logs` рекурсивно

<h2 id="chapter-vii" >Глава VII</h2>
<h3 id="ex03">Упражнение 03: Архивирование штуковин</h3>

Это последний инструмент что мы будем реализовать для этого дня это инструмент ротации логов. "Ротация логов" (log rotation) это процесс когда старый лог файл архивируется и выносится на хранение, так логи не будут копиться для одного файла бесконечно.

```bash
# Будет создан файл /path/to/logs/some_application_1600785299.tag.gz
# где 1600785299 это отметка времени в UNIX формате сделанная для `some_application.log`
./myRotate /path/to/logs/some_application.log
```
тебе поможет: [MTIME](https://linuxize.com/post/linux-touch-command/)

```
# Будет создано два tar.gz файла с временными отметками (одна для каждого лога) 
# и поместит их в папку /data/archive
./myRotate -a /data/archive /path/to/logs/some_application.log /path/to/logs/other_application.log
```

**Важно**: как в упражнении 01 ты должен использовать горутины для распалеливания архивирования нескольких файлов **одновременно**.

# 